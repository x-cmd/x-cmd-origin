# shellcheck shell=bash

xrc log advise xrc
xrc assert

# Section: Testcase for advise awk code

test_at(){

    assert_stdout "test123 option @a" <<A
@a1
@a2
@a3
A

    assert_stdout "test123 option @" <<A
@a
@b
A

    assert_stdout "test123 option @a ''" <<A
atcmd
@
A
}

test_hyphen(){
    assert_stdout "test123 option -" <<A
-a
-c
-p
-d
-f
@
A

assert_stdout "test123 option --" <<A
--repo2
--repo3
--priviledge
--dict
--cmd
--colon
--flag
@
A

}

test_marg(){
    assert_stdout "test123 option -a ''" <<A
m1-a
m1-b
m1-c
A

    assert_stdout "test123 option -a m1-a ''" <<A
m2-a
m2-b
m2-c
A
}

test_cmd(){

    assert_stdout "test123 option atcmd @" <<A
#> myself_ls
A

    assert_stdout "test123 option --cmd ''" <<A
#> ___advise_ls
A
}

test_option(){

    assert_stdout "test123 option atcmd --ls ''" <<A
#> ___advise_ls
A

    assert_stdout "test123 option -c ''" <<A
m3-a
m3-b
m3-c
A

    assert_stdout "test123 option --priviledge ''" <<A
private
public
A

    assert_stdout "test123 option -d ''" <<A
e
c:
A

    assert_stdout "test123 option -d e" <<A
edwinjhlee
labve
A

    assert_stdout "test123 option -d c:" <<A
c:abc
c:aaa
A
}

test_rarg(){
    assert_stdout "test123 rarg abc ''" <<A
#> ___advise_lsd; printf '..\n.\n../\n-'
A

    assert_stdout "test123 rarg ''"<<A
abc
abt
.c
:a
A

    assert_stdout "test123 rarg s s ''"<<A
#> ___advise_ls
A

    assert_stdout "test123 rarg s s s ''"<<A
[A-Z]
[a-z]
[0-9]
A
}

test_subcmd(){
    assert_stdout "test123 s"<<A
subcmd
subcommand
A

    assert_stdout "test123 subcmd create"<<A
create1
create2
create3
create4
A

    assert_stdout "test123 subcmd repo ''"<<A
#> ls
A

    assert_stdout "test123 subcmd --ufuu ''"<<A
/dev/stdout
/dev/stderr
A


    assert_stdout "test123 subcmd -u ''"<<A
/dev/stdout
/dev/stderr
A

    assert_stdout "test123 subcmd  -t ''"<<A
#>  [ -z "\$(printf "%s" "\$cur" | tr -d [0-9])" ] && echo s,d,m | tr ',' '\n' | xargs -n 1 printf "\$cur%s\n"
A

    assert_stdout "test123 subcmd -n ''"<<A
#> printf %s 0,1,2,3,4,5,6,7,8,9 | tr ',' '\n' | xargs -n 1 printf "\$cur%s\n"
A

    assert_stdout "test123 subcmd --ncc ''"<<A
#> ___advise_seq 1 10000
A

    assert_stdout "test123 subcmd -d ''"<<A
,
|
-
:
/
A

    assert_stdout "test123 subcmd -i ''"<<A
#> ___advise_ls \${cur:-\$HOME/.ssh/}
A

    assert_stdout "test123 subcmd -p ''"<<A
#> ___advise_seq 1/65535
A

    assert_stdout "test123 subcmd -A ''"<<A
[-][[hh]mm]SS
A

    assert_stdout "test123 subcmd -m ''"<<A
[[CC]YY]MMDDhhmm[.SS]
A

    assert_stdout "test123 subcmd -q ''"<<A
[A-Z]
[a-z]
[0-9]
A

}


# Section: utilities

test123(){
    local fp="./testcases/test.json"
    local IFS=$'\002' # IFS="$(printf "\002")"
    # echo "Before awk: $*" > /dev/stderr

    s="$*"

    {
        cat "$fp"
        printf "\034%s\034" "$s"  # printf "\034${s}\034"
    } | awk -f "./v0.awk" # 2>/dev/null
}

# list all the file in the directory, and add the @ to the behind of the file name
myself_ls(){
    ls -1 "$@" | sed -e 's/^/@/'
}

start_test() {
    < "$1" awk '$0~/^test_[^\(]+\(\)/{ gsub(/\(\)\{/, "", $0); print $0 }' | while read -r line; do
        echo "Testing Function: $line"
        if ! eval "$line"; then
            printf "\033[0;31m======= Fail at function: %s \033[0m" "$line" >&2
            break
        fi
    done
}

start_test ./testcases/v0_test

# Section: for the interactive ui
rm -rf test123
. ./v0
___ADVISE_AWK_PATH="./v0.awk"
advise compt "./testcases/test.json"
