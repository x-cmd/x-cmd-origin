# shellcheck shell=sh disable=SC3043 # xrc

xrc param/v0

# Section: main

___x_cmd_theme_control(){
    local zinit
    local font
    [ -n "$ZSH_VERSION" ] && zinit="zinit    \"init the zsh environment\""
    [ -z "$SSH_CONNECTION" ] && [ ! -f "/.dockerenv" ] && font="font    \"install powerline font\""
    param:dsl <<A
subcommands:
    ls          "list all theme"
    use         "use theme when starting the shell"
    try         "try theme"
    ${zinit}
    ${font}
    unset       "unset the theme"
A
    param:run

    if [ -z "$PARAM_SUBCMD" ]; then
        ___x_cmd_theme_control _param_help_doc
        return 0
    fi

    "___x_cmd_theme_control_${PARAM_SUBCMD}" "$@"
}

___x_cmd_theme_which(){
    local name="${1:?Provide name}"
    local cache="$___X_CMD_ROOT/.tmp/theme/$name"

    local expiration=""
    if [ "$name" = "index.yml" ]; then
        expiration=1
    fi
    ___x_cmd_curl_gitx x-cmd theme main "${name}" "$cache" "$expiration" && printf "%s" "$cache"
}

# EndSection

# Section: subcmd

___x_cmd_theme_control_ls() {
    param:void
    local fp
    if fp="$(___x_cmd_theme_which index.yml)"; then
        awk '{ print $2; }' <"$fp"
    fi
}

xrc theme/_v0/lib
xrc theme/_v0/style

___x_cmd_theme_control_use(){
    param:dsl <<A
advise:
    #1          awk '{ print \\\$2; }' <\\\$___X_CMD_ROOT/.tmp/theme/index.yml
options:
    #1          "return theme list name"
A
    param:run

    local name="${1:-ys}"
    ___x_cmd_theme_control_try "$name" && \
        x boot rc add "x-theme" "xrc theme && ___x_cmd_theme_control try $name"
}

___x_cmd_theme_control_unset(){
    param:void
    local ___X_CMD_ROOT_RC="$___X_CMD_ROOT/.boot/rc"
    if [ ! -f "$___X_CMD_ROOT_RC" ]; then
        printf "%s\n" "The configuration file does not exist,unset failed"
        return 0
    fi
    x boot rc del x-theme
    printf "\033[32mUnset the theme successfully! \033[1;33mNow you can restart your terminal.\033[0m \n"
}

___x_cmd_theme_control_try(){
    param:dsl <<A
advise:
    #1          awk '{ print \\\$2; }' <\\\$___X_CMD_ROOT/.tmp/theme/index.yml
options:
    #1          "return theme list name"
A
    param:run

    local name="${1}"
    case "$name" in
        ys|"")
            ___x_cmd_theme_load_format "$(xrc which theme/_v0/ys)"
            return
            ;;
        */*)
            ___x_cmd_theme_load_format "$(xrc which "$name")"
            return
            ;;
    esac
    local _cache_source="$___X_CMD_ROOT/.tmp/theme/index.yml"
    if [ -f "$_cache_source" ];then
        awk -v name="$name" '
$2==name{ code=1; exit 0; };
END{
    if (code==1) exit 0
    else exit 1
}' <"$_cache_source"

    else
        ___x_cmd_theme_control_ls | awk -v name="$name" '
$1==name{ code=1; exit 0; };
END{
    if (code==1) exit 0
    else exit 1
}'
    fi

    local code=$?
    if [ "$code" != 0 ]; then
        printf "\033[31m%s\033[33m%s\n%s \033[1;36m%s\033[0m\n" \
            "[x-cmd]: Not found theme in cache." " Check the theme name is exist." \
            "Or you can try run command to update cache." "\`x theme ls\`"
        return $code
    fi

    local fp
    if fp="$(___x_cmd_theme_which "$name")"; then
        ___x_cmd_theme_load_format "$fp"
        return 0
    fi
    return 1
}

___x_cmd_theme_control_rollback(){
    :
}

___x_cmd_theme_control_zinit(){
    param:void
    local _have_loaded_theme
    _have_loaded_theme=$([ -f "$___X_CMD_ROOT/.boot/rc" ] && x boot rc ls | grep 'x-theme')
    # load theme
    [ -z "$_have_loaded_theme" ] && ___x_cmd_theme_control_use ""
    # load zsh plugins
    [ -z "$ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME" ] && ___x_cmd_theme_control_use_plugin "zsh-autosuggestions"
    [ -z "$ZSH_HIGHLIGHT_REVISION" ] && ___x_cmd_theme_control_use_plugin "zsh-syntax-highlighting"
    # load font
    [ -z "$SSH_CONNECTION" ] && [ ! -f "/.dockerenv" ] && ___x_cmd_theme_control_font
    printf "%s\n" "[x-cmd]: Successfully initialized."
}

___x_cmd_theme_control_use_plugin() {
    { [ -z "$1" ] || [ -z "$ZSH_VERSION" ]; } && return 1
    xrc theme/third-party/"$1"/"$1".plugin.zsh
    x boot rc add "x-plugin-$1" "[ -n \"\$ZSH_VERSION\" ] && xrc theme/third-party/$1/$1.plugin.zsh"
}

___x_cmd_theme_control_font() {
    param:void
    local _font_dir
    local _font_name
    if [ "$(uname)" = "Darwin" ]; then
        # MacOS
        _font_dir="$HOME/Library/Fonts"
        _font_name='MonacoPL.ttf'
    else
        # Linux
        _font_dir="$HOME/.local/share/fonts"
        mkdir -p "$_font_dir"
        _font_name='CascadiaCodePL.ttf'
    fi
    if [ -f "$_font_dir/$_font_name" ];then
        printf "%s\n" "[x-cmd]: font already installed: $_font_dir"
        return 0
    fi
    local cache="$_font_dir/$_font_name"
    local expiration=""
    ___x_cmd_curl_gitx x-cmd theme main "font/$_font_name" "$cache" "$expiration"
    if [ -n "$(command -v fc-cache)" ] ; then
        printf "%s\n" "[x-cmd]: Resetting font cache, this may take a moment..."
        fc-cache -f "$_font_dir"
    fi
}

# Best efforts to retrieve background color.
# Works: terminal app in macos, ...
# Now works: vscode, ...
# Reference:
# 1. https://unix.stackexchange.com/questions/172548/how-to-determine-the-current-color-of-the-console-output
# 2. https://newbedev.com/how-to-determine-a-terminal-s-background-color
___x_cmd_theme_control_get_current_background_color(){
    local oldstty
    oldstty=$(stty -g)
    local Ps=${1:-11}

    stty raw -echo min 0 time 0
    printf "\033]$Ps;?\033\\"
    sleep 0.00000001

    local answer
    read -r answer
    local result
    result=${answer#*;}
    stty "$oldstty"
    # Remove escape at the end.
    printf "%s" "$result" | sed 's/[^rgb:0-9a-f/]\+$//'
}

# EndSection

xrc setmain ___x_cmd_theme_control
