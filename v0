# shellcheck shell=bash disable=SC2039,3043

# author:       Li Junhao           l@x-cmd.com    edwinjhlee.github.io

if [ -z "${ZSH_VERSION}${BASH_VERSION}" ]; then
    x log info "advise is only available in 'bash' or 'zsh'."
elif ! ___ADVISE_AWK_PATH="$(xrc which advise/v0.awk)"; then
    x log error "Cannot introduce advise"
else

x log init advise
______X_CMD_ADVISE_V0_FILEPATH="$(xrc which advise/v0)"

# Section : advise entrance

advise(){
    local op="${1}"; shift 2>/dev/null
    case "$op" in
        ls)
            ls "$@" "${TMPDIR%/}/.x-cmd/advise_auto_json" ;;
        rm)
            if [ "$#" -eq 0 ]; then
                rm -rf "${TMPDIR%/}/.x-cmd/advise_auto_json"/*
            else
                rm -rf "${TMPDIR%/}/.x-cmd/advise_auto_json"/"$1"
            fi
            ;;
        which)
            if [ "$#" -eq 0 ]; then
                printf "%s" "${TMPDIR%/}/.x-cmd/advise_auto_json"
            else
                printf "%s/%s" "${TMPDIR%/}/.x-cmd/advise_auto_json" "$1"
            fi
            ;;
        cat)
            local mod
            for mod in "$@"; do
                cat "${TMPDIR%/}/.x-cmd/advise_auto_json/$mod"
            done
            ;;
        man)
            ___advise_man "$@" ;;
        init|new)
            ___advise_main "$@" ;;
        del)
            complete -r "${1:?Provide function name}"
            ;;
        obj-new)
            local aliasname="${2:?Provide alias name}"
            local filepath="${TMPDIR%/}/.x-cmd/advise_auto_json/$op"

            # TODO: There is one more solution. But it is not not worked in ZSH. Please figure it out.
            # complete -C "___advise_completer \"$filepath\"" "$aliasname"

            eval "
            function ______adviser_of_$op(){
                ___advise_completer \"$filepath\"
            }
            "
            complete -F "______adviser_of_$op" "$aliasname"
            ;;
        obj-del)
            local aliasname="${2:?Provide alias name}"

            complete -r "$aliasname"
            if ! complete | grep "______adviser_of_$op" 1>/dev/null 2>&1; then
                unset -f "______adviser_of_$op"
            fi
            ;;
         _x_cmd_advise_json)
            cat <<A
{
    "ls": null,
    "rm": "advise ls",
    "which|cat|init|new": "ls ${TMPDIR%/}/.x-cmd/advise_auto_json/",
    "man": {
        "ls": null,
        "update": null,
        "rm": null,
        "which": "advise man ls",
        "load": null
    },
    "del":null,
    "obj-new":null,
    "obj-del": null
}
A
            return 126
            ;;
        ""|help)
            # TODO: help doc
            printf "%s\n" "Show advise help" >&2; return 1
            ;;
        *)
            ___advise_main "$op" "$@" ;;
    esac
}

# EndSection

# Section : adviser helper function: ls lsd seq

___advise_lsd(){
    local l
    # local localdir="${1:-${cur:-.}}"
    # ls -d "${localdir}"*/ 2>/dev/null | while read -r l; do
    #     printf "%s\n" "${l%/}"
    # done

    local localdir="${1:-${cur:-""}}"
    compgen -d "${localdir}" 2>dev/null | while read -r l; do
        printf "%s/\n" "${l%/}"
    done
}
___advise_ls_grep(){
    local localopt="${1:-${cur:-""}}"
    ls | grep -E "${localopt}" 2>/dev/null
}
___advise_ls(){
    local localdir="${1:-${cur:-""}}"

    if [ -z "$localdir" ]; then
        ls
        return
    fi

    if [ "${localdir%/*}" = "${localdir}" ]; then
        folder=""
        pattern="${localdir}"

    else
        folder="${localdir%/*}"
        pattern="${localdir##*/}"
    fi

    ls "${folder:-.}" | awk -v folder="$folder" -v pattern="$pattern" 'match($0, "^" pattern){
        if (folder == "") {
            print $0
        } else {
            print folder "/" $0
        }
    }' 2>/dev/null
}

# 1-10
___advise_seq(){
    local curnum="${cur:-""}"
    awk -v range="$1" -v cur="$cur" '
function inside(num, start, end, step){
    if ( (num < start) || (num > end) ) return 0
    if ( ( num - start ) % step == 0 ) return 1
    return 0
}

BEGIN{

    arr_len = split(range, arr, /\//)
    start = arr[1]
    end = arr[2]
    step = arr[3]
    if (step == "") step = 1

    num = (end - start + 1) / step
    if (num < 16) {
        for (i=start; i<=end; i=i+step) print i
        exit(0)
    }

    if (cur !~ /[0-9]+/) {
        exit(0)
    }

    if (inside(cur, start, end, step) == 1) print cur

    cur = cur * 10
    for (i=0; i<=9; ++i) {
        newnum = cur + i
        if (inside(newnum, start, end, step) == 1) print newnum
    }
}
' <<A
A

}

___advise_get_result(){
    local offset="${2:-0}"

    local resname="${1:-${COMP_WORDS[offset]}}"

    local filepath
    case "$resname" in
        /*) filepath="$resname" ;;
        -)  filepath=/dev/stdin ;;
        *)  filepath="${TMPDIR%/}/.x-cmd/advise_auto_json/$resname" ;;
    esac

    local OLDIFS="$IFS"
    local IFS=$'\002' # IFS="$(printf "\002")"

    # Delete $offset numbers from the COMP_WORDS
    local i
    local words=()
    for ((i=0; i<=$(($COMP_CWORD-$offset)); ++i)); do
        words+=( "${COMP_WORDS[i+offset]}" )
    done

    COMP_WORDS=("${words[@]}")
    COMP_CWORD="$(( ${#words[@]}-1 ))"

    s="${COMP_WORDS[*]}"
    s="${s#*$IFS}"

    # TODO: Can be optimized.
    local cur_1="${COMP_WORDS[COMP_CWORD-1]}"
    case "$cur_1" in
        *@|*:)
            if [ "${COMP_LINE% }" != "${COMP_LINE}" ]; then
                s="${s%$cur_1$IFS$cur}"
                s="${s}${cur_1}$cur"
            fi
            ;;
        *)
    esac

    IFS=$'\n'   # Bash/Zsh Only

    [ -f "$filepath" ] || return

    local result
    result="$(
        {
            cat "$filepath"
            printf "\034%s\034" "$s"  # printf "\034${s}\034"
        } | awk -f "$___ADVISE_AWK_PATH" 2>/dev/null
    )"
    IFS="$OLDIFS"

    local cmd="${result##*#> }"
    local cmd_result=""
    if [ "$cmd" != "$result" ]; then
        cmd_result="$(eval "$cmd")"
        result="${result%%#> *}"
    fi

    printf "%s" "$result
$cmd_result"
}

# EndSection

# Section : main

___advise_main(){
    local func="${1:?Provide function name}"
    local filepath="${2}"
    local tmp_filepath=${TMPDIR%/}/.x-cmd/advise_auto_json/$func
    mkdir -p "$(dirname "$tmp_filepath")"

    if [ "-" = "$filepath" ]; then
        filepath=$tmp_filepath
        advise_log "Pipe standard input to $filepath"
        cat >"$filepath"
    elif [ -z "$filepath" ]; then
        ___advise_update "$func"
        local filepath=$tmp_filepath
        if [ -n "$___XRC_UDPATE" ] || [ ! -f "$filepath" ]; then
            advise_log debug "Pipe the result of \"$func _x_cmd_advise_json\" to $filepath"
            local content
            content="$(X_CMD_ADVISE_FUNC_NAME=$func eval "$func" _x_cmd_advise_json)"
            if [ $? = 126 ]; then
                printf "%s" "$content" >"$filepath"
            else
                advise_log warn "Fail to write file because the return code of \"$func _x_cmd_advise_json\" is not 126."
                return 0
            fi
        fi
    else
        advise_log debug "Copy self-defined file $filepath to $tmp_filepath"
        cp "$filepath" "$tmp_filepath"
        filepath="$tmp_filepath"
    fi

    complete -F "___advise_completer" "$func"
}

___advise_update(){
    local func="${1:?Provide function name}"
    local tmp_filepath=${TMPDIR%/}/.x-cmd/advise_auto_json/$func

    if [ -f "$tmp_filepath" ] && [ -z "$(find "$tmp_filepath" -mtime -1)" ]; then
        advise_log info "update: $tmp_filepath"
        rm -rf "$tmp_filepath"
        ___advise_main $func
    fi
}

___advise_run(){

    local offset="${2:-0}"
    local resname="${1:-${COMP_WORDS[0]}}"

    if [ -z "$___ADVISE_RUN_CMD_FOLDER" ]; then
        ___ADVISE_RUN_CMD_FOLDER="${TMPDIR%/}/.x-cmd/advise_auto_json"
    fi

    local filepath
    case "$resname" in
        /*) filepath="$resname" ;;
        -)  filepath=/dev/stdin ;;
        *)
            if [ -d "$___ADVISE_RUN_CMD_FOLDER/$resname" ]; then
                filepath="$___ADVISE_RUN_CMD_FOLDER/$resname/advise.json"
            else
                filepath="$___ADVISE_RUN_CMD_FOLDER/$resname"
            fi
            ;;
    esac

    shift 2>/dev/null

    if [ -n "$BASH_VERSION" ] && [ "${BASH_VERSION#3}" = "${BASH_VERSION}" ]; then
        local last="${COMP_WORDS[COMP_CWORD]}"
        case "$last" in
            \"*|\'*)
                COMP_LINE="${COMP_LINE%$last}"
                words=( $COMP_LINE )
                words+=("$last")
                ;;
            *)
                words=( $COMP_LINE )
                ;;
        esac

        # Ends with space
        if [ "${COMP_LINE% }" != "${COMP_LINE}" ]; then
            words+=( "" )
        fi

        COMP_WORDS=("${words[@]}")
        COMP_CWORD="$(( ${#words[@]}-1 ))"
    fi

    local cur="${COMP_WORDS[COMP_CWORD]}"

    if [ "$cur" == "" ]; then
        # Notice: The following line handle zsh compatibility problem.
        # In zsh, When input word is empty, COMP_WORDS[COMP_CWORD] does not exist.
        # In bash, When input word is empty, COMP_WORDS[COMP_CWORD] exist, and it is ""
        # This will result in difference value of "${COMP_WORDS[*]}"
        COMP_WORDS[COMP_CWORD]=""
    fi

    local OLDIFS="$IFS"
    local IFS=$'\002' # IFS="$(printf "\002")"

    s="${COMP_WORDS[*]}"
    s="${s#*$IFS}"

    local cur_1="${COMP_WORDS[COMP_CWORD-1]}"
    case "$cur_1" in
        *@|*:)
            if [ "${COMP_LINE% }" != "${COMP_LINE}" ]; then
                s="${s%$cur_1$IFS$cur}"
                s="${s}${cur_1}$cur"
            fi
            ;;
        *)
    esac

    IFS=$'\n'   # Bash/Zsh Only

    [ -f "$filepath" ] || return

    local result
    result="$(
        {
            cat "$filepath"
            printf "\034%s\034" "$s"  # printf "\034${s}\034"
        } | awk -f "$___ADVISE_AWK_PATH" 2>/dev/null
    )"
    IFS="$OLDIFS"

    if [ -z "$ZSH_VERSION" ];then
        if [[ "$result" =~ [:=\/]$ ]];then
            compopt -o nospace
        else
            compopt +o nospace
        fi
    fi

    local cmd="${result##*#> }"
    local cmd_result=""
    if [ "$cmd" != "$result" ]; then
        cmd_result="$(eval "$cmd" 2>/dev/null)"
        result="${result%%#> *}"
    fi

    # shellcheck disable=SC2207
    COMPREPLY=(
        $(
            compgen -W "$result
$cmd_result" -- "$cur"
        )
    )

    __ltrim_completions "$cur" "@"
    __ltrim_completions "$cur" ":"
    __ltrim_completions "$cur" "="

}

__ltrim_completions()
{

    local i=${#COMPREPLY[*]}
    ((i == 0)) && return 0
    if [[ $1 == *$2* && $COMP_WORDBREAKS == *$2* ]]; then
        # Remove colon-word prefix from COMPREPLY items
        local colon_word=${1%"${1##*$2}"}
        COMPREPLY=("${COMPREPLY[@]}")
        while ((i-- > 0)); do
            COMPREPLY[i]=${COMPREPLY[i]#"$colon_word"}
        done
    fi
}

___advise_completer() {
    # Interesting ... Passing
    ___ADVISE_RUN_CMD_FOLDER= ___advise_run ""
}

# EndSection

if [ -n "$ZSH_VERSION" ] && [ "$(autoload | grep bashcompinit)" = "" ]; then
    autoload -U +X bashcompinit compinit && bashcompinit && compinit
fi

advise init advise
fi

# Section: man

___advise_man_exists(){
    [ -d "$___X_CMD_ROOT/.tmp/advise/src" ]
}

___advise_man_update(){
    local CACHE="$___X_CMD_ROOT/.tmp/advise/all.tar.gz"
    local srcfolder="$___X_CMD_ROOT/.tmp/advise/src"

    local url="https://gitee.com/x-cmd/advise/raw/main/dist/all.tgz"
    if [ "$___X_CMD_IN_CHINA_NET" != 1 ]; then
        url="https://raw.githubusercontent.com/x-cmd/advise/main/dist/all.tgz"
    fi

    if ___x_cmd_curl "$url"; then
        [ -d "$srcfolder" ] && rm -rf "$srcfolder"
        mkdir -p "$srcfolder"
        tar xvf "$CACHE" -C "$srcfolder"
    fi
}

___advise_man_ls(){
    if ___advise_man_exists || ___advise_man_update; then
        ls "$___X_CMD_ROOT/.tmp/advise/src"
    fi
}

___advise_man_which(){
    local name="${1:?Provide name}"
    if ___advise_man_exists || ___advise_man_update; then
        local p="$___X_CMD_ROOT/.tmp/advise/src/$name/advise.json"
        [ -f "$p" ] && printf "%s" "$p"
    fi

    return 1
}

# ___advise_man_load(){
#     local cmd="${1:?Provide cmd}"
#     local p="$(___advise_man_which "$cmd")"
#     if [ ! -f "$p" ]; then
#         printf "%s\n" "$cmd.json Not found. You could try 'advise man update' for updates." >&2
#         return 1
#     fi
#     compgen "___advise_man_completer" "$cmd"
# }

___advise_man_load(){
    local i
    for i in $(___advise_man_ls); do
        if s=$(complete -p "$i" 1>/dev/null 2>&1); then
            [[ "$s" == *___advise_completer* ]] && continue
        fi
        complete -F "___advise_man_completer" "$i"
    done
}

___advise_man_rm(){
    local srcfolder="$___X_CMD_ROOT/.tmp/advise/src"
    local CACHE="$___X_CMD_ROOT/.tmp/advise/all.tar.gz"
    if ___advise_man_exists; then
        rm -rf "$srcfolder"
    fi
}

___advise_man_completer() {
    # Interesting ... Passing
    ___ADVISE_RUN_CMD_FOLDER="$___X_CMD_ROOT/.tmp/advise/src/" ___advise_run ""
}

___advise_man(){
    local op="${1:?Provide subcommand}"; shift
    case "$op" in
        ls)         ___advise_man_ls ;;
        update)     ___advise_man_update ;;
        which)      ___advise_man_which "$@" ;;
        load)       ___advise_man_load ;;
        rm)         ___advise_man_rm ;;
        *)          ___advise_man_load "$op" "$@" ;;
    esac
}

# EndSection
